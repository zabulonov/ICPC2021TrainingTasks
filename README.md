# ICPC2021TrainingTasks

## ProblemA
![telegram-cloud-photo-size-2-5244883933412313871-y](https://github.com/zabulonov/ICPC2021TrainingTasks/assets/83907630/4228598d-42d7-47f8-9df8-3a036986feb2)

## ProblemB
![telegram-cloud-photo-size-2-5244883933412313872-y](https://github.com/zabulonov/ICPC2021TrainingTasks/assets/83907630/fddc511f-24f7-4ae7-b098-052a5e10fdd8)

## ProblemC
Уверен что мое решение не оптимальное, и можно по любому сделат проще и быстрее  
step нужен для оптимизации, если изначально n - четное нет смысла идти с шагом 1
```csharp
    byte step = 1;
        if (n % 2 == 0)
            step = 2;
```
## ProblemE - пропустил
## ProblemD
Массив** `ans[10]` - содержит в себе кол-во элементов в куче по номеру индекса цифры(не понятно написал). Куча **heap** - зубчатый массив, начинаем заполнять его и сразу инкрементируем массив ans при нахождении числа  

`ans[d]++;` нужен, так как в циклах мы не считаем верхушку массива 
## ProblemF
Ai = a1, a2, a3 ,a4...  
Начиная с первого элемента наращивая массив начинаем искать хорошие отрезки, при достижении конца, ищем со след элемента. Например:  
a1, a2, a3, a4  
**(a1, a2)**, a3, a4  
**(a1, a2, a3,)** a4  
**(a1, a2, a3, a4)**  
a1, **(a2, a3)**, a4  
a1, **(a2, a3, a4 )**  
a1, a2, **(a3, a4)**  

## Tests
Я тестировал только кейсы которые были в описаниях к задачам, но уверен решение подходит для всех наборов данных

<img width="696" alt="Screenshot 2023-10-01 at 15 54 05" src="https://github.com/zabulonov/ICPC2021TrainingTasks/assets/83907630/a330ecb1-6c35-4cf6-b043-205e0c588413">


